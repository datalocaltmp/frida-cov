#!/usr/bin/env python
from __future__ import print_function

'''
This is the Python portion of visualizing Android Code Coverage within a native executable. 
Originally this code was written by @gaasedelen for lighthouse, and has since been modified
by @datalocaltmp.

Note that this python script expects to take in a file generated by the frida-drcov.js
script injected via a frida-gadget.
'''

import argparse
import json
import sys

# These are global so we can easily access them from the frida callbacks or
# signal handlers. It's important that bbs is a set, as we're going to depend
# on it's uniquing behavior for deduplication
modules = []
bbs = set([])
outfile = 'frida-cov.log'
infile = 'rawcov.dat'

# This converts the object frida sends which has string addresses into
#  a python dict
def populate_modules(image_list):
    global modules

    for image in image_list:
        idx  = image['id']
        path = image['path']
        base = int(image['base'], 0)
        end  = int(image['end'], 0)
        size = image['size']

        m = {
                'id': idx,
                'path': path,
                'base': base,
                'end': end,
                'size': size}

        modules.append(m)

    print('[+] Got module info.')

# called when we get coverage data from frida
def populate_bbs(data):
    global bbs
    # we know every drcov block is 8 bytes, so lets just blindly slice and
    #  insert. This will dedup for us.
    block_sz = 8
    for i in range(0, len(data), block_sz):
        bbs.add(bytes(data[i:i+block_sz]))

# take the module dict and format it as a drcov logfile header
def create_header(mods):
    header = ''
    header += 'DRCOV VERSION: 2\n'
    header += 'DRCOV FLAVOR: frida\n'
    header += 'Module Table: version 2, count %d\n' % len(mods)
    header += 'Columns: id, base, end, entry, checksum, timestamp, path\n'

    entries = []

    for m in mods:
        # drcov: id, base, end, entry, checksum, timestamp, path
        # frida doesnt give us entry, checksum, or timestamp
        #  luckily, I don't think we need them.
        entry = '%3d, %#016x, %#016x, %#016x, %#08x, %#08x, %s' % (
            m['id'], m['base'], m['end'], 0, 0, 0, m['path'])

        entries.append(entry)

    header_modules = '\n'.join(entries)

    return ("%s%s\n" % (header, header_modules)).encode("utf-8")

# take the recv'd basic blocks, finish the header, and append the coverage
def create_coverage(data):
    bb_header = b'BB Table: %d bbs\n' % len(data)
    return bb_header + b''.join(data)

def save_coverage():
    with open(infile, 'rb') as i:
        rawcov = i.readline()
        rawcov = rawcov[:-1]
        rawcov = rawcov + bytes(']}', 'utf-8')
        
        data = json.loads(rawcov)
        populate_modules(data['map'])
        populate_bbs(data['bbs'][0])

    header = create_header(modules)
    body = create_coverage(bbs)

    with open(outfile, 'wb') as h:
        h.write(header)
        h.write(body)

def main():
    global outfile
    global infile

    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--outfile',
            help='coverage file',
            default='frida-cov.log')
    parser.add_argument('-i', '--infile',
            help='raw input file',
            default='rawcov.dat')

    args = parser.parse_args()

    outfile = args.outfile
    infile = args.infile

    save_coverage()

    print('[!] Done')

    sys.exit(0)

if __name__ == '__main__':
    main()
